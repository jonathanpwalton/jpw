#!/usr/bin/env bash

NAME="jpw"
VERSION="2025.03.25"
DESCRIPTION="a simple build-from-source package manager for GNU/Linux"

error() {
	printf "error: %s\n" "$1"
	exit 1
}

cwd() {
	cd "$1" || error "unable to cd $1"
}

require_root() {
	if [ "$EUID" -ne 0 ]; then
		error "you cannot use this command unless you are root"
	fi
}

usage() {
	printf "%s %s, %s\n" "$NAME" "$VERSION" "$DESCRIPTION"
	printf "usage: %s <command>\n" "$0"

	declare -A COMMANDS=(
		["help"]="print this help text and exit"
		["install"]="install a package"
		["uninstall"]="uninstall a package"
		["installed"]="list installed packages"
	)

	for COMMAND in "${!COMMANDS[@]}"; do
		printf "  %-20s %s\n" "$COMMAND" "${COMMANDS[$COMMAND]}"
	done

	exit 0
}

declare -A installed=()

if [[ -e /var/cache/jpw/.installed ]]; then
	mapfile INSTALLED_LINES < /var/cache/jpw/.installed

	for INSTALLED_LINE in "${INSTALLED_LINES[@]}"; do
		IFS=':' read -ra LINE <<< "$INSTALLED_LINE"
		installed[${LINE[0]}]=${LINE[1]}
	done
fi

write_installed () {
	require_root
	rm -f /var/cache/jpw/.installed
	for pkg in "${!installed[@]}"; do
		echo "${pkg}:${installed[$pkg]}" >> /var/cache/jpw/.installed
	done
}

uninstall_package() {
	pkg=$1

	cd "/var/cache/jpw/$pkg" || error "failed to cd /var/cache/jpw/$pkg"

	if ! /usr/bin/env bash uninstall; then
		error "failed to uninstall $pkg"
	fi

	rm -rf "/var/cache/jpw/$pkg"
	unset "installed[$pkg]"
	write_installed
}

install_package() {
	pkg=$1
	ver=$2

	if [[ "${installed[$pkg]+1}" ]]; then
		printf "'%s' version '%s' was previously installed, do you wish to replace it with version '%s'? " "$pkg" "${installed[$pkg]}" "$ver"
		read -r answer

		if [[ ${answer,,} != "y" ]] && [[ ${answer,,} != "yes" ]]; then
			return
		fi

		uninstall_package "$pkg"
	fi

	tmpdir="$(mktemp)dir"
	mkdir "$tmpdir"
	cwd "$tmpdir"
	wget --no-cache -q --show-progress "https://raw.githubusercontent.com/jonathanpwalton/jpw/refs/heads/main/pkg/$pkg"

	case "$?" in
		4 ) error "network failure";;
		8 ) error "no such package $pkg";;
	esac

	if [[ $ver = latest ]]; then
		ver="$(/usr/bin/env bash "$pkg" latest)"
	fi

	if [[ -z $(/usr/bin/env bash "$pkg" versions "$ver" src) ]]; then
		error "no such version '$ver' for '$pkg'"
	fi

	dir="/var/cache/jpw/$pkg"
	src=$(/usr/bin/env bash "$pkg" versions "$ver" src)
	dst=$(/usr/bin/env bash "$pkg" versions "$ver" dst)
	build=$(/usr/bin/env bash "$pkg" versions "$ver" build)
	
	case "$src" in
		*.tar.* ) extract="tar xf";;
		* ) error "extraction unimplemented for $src";;
	esac

	mkdir -p "$dir"
	cwd "$dir"
	
	case "$build" in
		gnu )
			echo "
				set -e
				wget -q --show-progress $src
				$extract $dir/$(basename "$src")
				rm -f $dir/$(basename "$src")
				cd $dir/$dst
				./configure
				make
				make install
				make clean
			" > install

			echo "
				set -e
				cd $dir/$dst
				make uninstall
			" > uninstall
		;; * )
			error "building unimplemented for $build";;
	esac

	if ! /usr/bin/env bash install; then 
		error "failed to install '$pkg' version '$ver'";
	fi

	installed[$pkg]=$ver
	write_installed
}

cmd=$1
shift

case "$cmd" in
	"" )
		error "command not supplied, try '$0 help' for more information";;
	help )
		usage;;
	install )
		require_root

		if [[ -z $1 ]]; then
			error "no package to install, try '$0 help' for more information"
		fi

		while (("$#")); do
			IFS=":" read -ra pkg_ver <<< "$1"

			if [[ -z ${pkg_ver[1]} ]]; then
				pkg_ver[1]="latest"
			fi

			install_package "${pkg_ver[0]}" "${pkg_ver[1]}"
			shift
		done;;
	uninstall )
		require_root

		if [[ -z $1 ]]; then
			error "no package to uninstall, try '$0 help' for more information"
		fi

		while (("$#")); do
			if [[ ! ${installed[$1]+1} ]]; then
				error "cannot uninstall not-installed package '$1'"
			fi

			uninstall_package "$1"
			shift
		done;;
	installed )
		for pkg in "${!installed[@]}"; do
			printf "%s %s\n" "$pkg" "${installed[$pkg]}"
		done;;
	* )
		error "invalid command '$cmd', try '$0 help' for more information"
esac
