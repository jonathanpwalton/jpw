#!/usr/bin/env python3

import os, shutil, tarfile as tar, io, math, socket

from os import fork, system, wait, chdir, setuid, readlink
from sys import argv, exit
from json import loads as parse_json, dump as write_json
from typing import Callable, IO as FileLikeObject
from urllib import request
from pathlib import Path
from subprocess import Popen as popen, PIPE
from urllib.parse import urljoin
from urllib.error import HTTPError, URLError
from itertools import chain

root: Path
conf: Path
cache: Path
lib: Path

indent = 0

def pull():
	if (len(argv) == 0):
		return update()
	
	if not (conf / 'repos').exists() or not (conf / 'repos').is_file():
		remove(conf / 'repos')
		
		def init_repos():
			open(conf / 'repos', "w").write(f'https://raw.githubusercontent.com/jonathanpwalton/packages/refs/heads/main\n')
		stage('initializing repository configuration', init_repos)
	
	def find_package(package: str):
		pkg = {}
		for repo in open(conf / 'repos').read().splitlines():
			try:
				with request.urlopen(f'{repo}/{package}') as req:
					pkg = parse_json(req.read())
					break
			except HTTPError:
				pass
		return pkg
	
	pkgset: set[str] = set()
	staging: list[dict] = []
	def assert_available():
		while len(argv) > 0:
			name = argv.pop(0)
			provider = None
			version = None

			if len(argv) > 0 and argv[0] == '-p':
				argv.pop(0)
				if len(argv) == 0: raise UsageException(f'package {repr(name)} has the provider option set, but no provider was given')
				provider = argv.pop(0)

			if len(argv) > 0 and argv[0] == '-v':
				argv.pop(0)
				if len(argv) == 0: raise UsageException(f'package {repr(name)} has the version option set, but no version was given')
				version = argv.pop(0)

			if name in pkgset:
				print(f'{' ' * indent}\033[0m\033[1;93mwarning: \033[0m{repr(name)} was provided more than once or automatically pulled as a dependency, skipping')
				continue
			else:
				pkgset.add(name)
			
			package = find_package(name)

			if not package:
				raise UsageException(f'no such package {repr(name)}')
			
			if provider is None:
				if len(package) == 1:
					provider = list(package.keys())[0]
				else:
					raise NotImplementedError
			elif provider not in package:
				raise UsageException(f'no such provider {repr(provider)} for {repr(name)}')
			
			if version is None:
				version = list(package[provider].keys())[0]
			elif version not in package[provider]:
				raise UsageException(f'no such version {repr(version)} for {repr(name)} from {repr(provider)}')

			staging.append({'name': name, 'provider': provider, 'version': version, 'meta': package[provider][version]})
	assert_available()

	def retrieve_sources():
		for package in staging:
			url: str = package['meta']['source']

			with io.BytesIO() as bytes:
				download(url, bytes)

				if tar.is_tarfile(bytes):
					with tar.open(fileobj=bytes) as tarball:
						package['folder'] = str(tarball.getmembers()[0].path[:tarball.getmembers()[0].path.index('/')] if '/' in tarball.getmembers()[0].path else tarball.getmembers()[0].path)

						for member in tarball.getmembers():
							if not member.path.startswith(package['folder']):
								raise UsageException(f'invalid source tarball for {repr(package['name'])}')
						
						remove(cache / package['folder'])
						tarball.extractall(cache, filter='tar')
				else:
					raise NotImplementedError
	stage('retrieving package sources', retrieve_sources)

	def build_package():
		package = staging.pop(0)
		match package['meta']['build']:
			case 'autoconf-makefile':
				system(f'chown -R 1 {repr(str(cache / package['folder']))}')

				if fork() == 0:
					chdir(cache / package['folder'])
					setuid(1)
					if pipe('./configure'): exit(1)
					if pipe('make'): exit(2)
					exit(0)

				if wait()[1]:
					raise UsageException(f'failed to configure and make {repr(package['name'])}')

				system(f'chown -R 0 {repr(str(cache / package['folder']))}')
				
				if fork() == 0:
					chdir(cache / package['folder'])
					if (pipe('make', 'install')): exit(1)
					pipe('make', 'clean')
					exit(0)

				if wait()[1]:
					raise UsageException(f'failed to install {repr(package['name'])}')

				remove(lib / package['name'])
				(lib / package['name']).mkdir(parents=True, exist_ok=False)
				(cache / package['folder']).rename(lib / package['name'] / package['folder'])
			case _:
				raise NotImplementedError(package['meta']['build'])
			
		write_json({
			'provider': package['provider'],
			'version': package['version'],
			'location': str(lib / package['name'] / package['folder']),
			'meta': package['meta']
		}, open(lib / package['name'] / '.meta', "w"))

	def build_packages():
		while len(staging):
			stage(f'building {staging[0]['name']}', build_package)
	stage(f'building package sources', build_packages)

def update():
	raise NotImplementedError

def drop():
	if len(argv) == 0:
		raise UsageException('expected one or more package names')
	
	staging = []
	while len(argv):
		if not (lib / argv[0]).is_dir() or not (lib / argv[0] / '.meta').is_file():
			raise UsageException(f'no such package {repr(argv[0])} is installed')
		staging.append(argv.pop(0))

	def drop_package(name: str = None):
		name = staging.pop(0) if name is None else name
		data = parse_json(open(lib / name / '.meta').read())
		
		match data['meta']['build']:
			case 'autoconf-makefile':
				if fork() == 0:
					chdir(data['location'])
					exit(pipe('make', 'uninstall'))

				if wait()[1]:
					raise UsageException(f'failed to drop {name}')
				
				remove(lib / name)
			case _:
				raise NotImplementedError

	def drop_packages():
		while len(staging):
			stage(f'dropping {staging[0]}', drop_package)
	stage('dropping packages', drop_packages)

def stage(label: str, fn: Callable[[], None]):
	global indent
	print(f'\033[0m\033[1;97m{' ' * indent}{'::' if indent == 0 else '=>'} {label}\033[0m')
	indent += 3
	fn()
	indent -= 3

def permit():
	error = False

	try:
		root.mkdir(parents=True, exist_ok=True)
		conf.mkdir(parents=True, exist_ok=True)
		cache.mkdir(parents=True, exist_ok=True)
		lib.mkdir(parents=True, exist_ok=True)
	except PermissionError:
		error = True
	
	for path in [root, conf, cache, lib]:
		if os.access(path, os.W_OK) != True or os.access(path, os.R_OK) != True or os.access(path, os.X_OK) != True:
			error = True
			break

	if error:
		raise UsageException('you do not have permission to perform this action')

def set_root(r: Path):
	global root, conf, cache, lib
	root = r
	conf = r / "etc/jpw"
	cache = r / "var/cache/jpw"
	lib = r / "var/lib/jpw"

def pipe(*cmd: str) -> int:
	p = popen(cmd, stdout=PIPE, stderr=PIPE, text=True, bufsize=1)
	for line in chain(iter(p.stdout.readline, ''), iter(p.stderr.readline, '')):
		if not line.isspace():
			print(f'{' ' * indent}{line}', end='')
	return p.wait()

def download(url: str, file: FileLikeObject):
	label = url[url.rindex('/') + 1:]

	print(f'{' ' * indent}{label: <80.80}', flush=True)
	with request.urlopen(url) as source:
		total = int(source.getheader('content-length', default=-1))

		while True:
			if not file.write(source.read(1024)):
				break

			print('\033[A\r\033[0K', end='\r', flush=True)
			if total == -1:
				print(f'{' ' * indent}{label: <74.74} {byte_fmt(file.tell())}', flush=True)
			else:
				print(f'{' ' * indent}{label: <28.28} {int(file.tell() / total * 100): >3}% [{'#' * int(file.tell() / total * 32): <32}] {byte_fmt(file.tell())} {byte_fmt(total)}', flush=True)
	file.seek(0)

# https://stackoverflow.com/a/41789397
def remove(path: Path):
	if not path.exists():
		return
		
	if os.path.isfile(path) or os.path.islink(path):
		os.remove(path)
	elif os.path.isdir(path):
		shutil.rmtree(path)
	else:
		raise RuntimeError("file {} is not a file or dir.".format(path))

# adapted from https://stackoverflow.com/a/14822210
def byte_fmt(size_bytes):
	if size_bytes == 0: return '   0B'
	i = int(math.floor(math.log(size_bytes, 1024)))
	unit = ("B", "K", "M", "G", "T", "P", "E", "Z", "Y")[i]
	s = size_bytes / math.pow(1024, i)
	return f'{s: >1.2f}{unit}' if s < 10 else f'{s: >2.1f}{unit}' if s < 100 else f'{s: >4.0f}{unit}'

class UsageException(Exception):
	def __init__(self, *args):
		super().__init__(*args)

if __name__ == "__main__":
	if os.name != 'posix':
		raise UsageException('this utility only works on posix systems')

	argv = list(filter(lambda a: a, argv[1:]))
	set_root(Path('/'))

	try:
		match None if len(argv) == 0 else argv.pop(0):
			case 'pull':
				permit()
				pull()
				exit(0)
			case 'drop':
				permit()
				drop()
				exit(0)
			case 'list':
				if lib.is_dir():
					[print(e.name) for e in lib.iterdir() if e.is_dir() and (e / '.meta').is_file()]
				exit(0)
			case 'help' | '-h' | '--help' | None:
				print('\n'.join([
					'usage: jpw <command>',
					'',
					'commands:',
					'  pull [<package> [-p <provider>] [-v <version>] ...]     update existing or install new packages',
					'  drop <package> ...                                      uninstall and remove packages',
					'  list                                                    list installed packages',
					'  help                                                    display this help text and exit'
				]))
				exit(0)
			case invalid:
				raise UsageException(f'invalid command {repr(invalid)}, try {repr('jpw help')} for more information')
	except UsageException as e:
		print(f'{' ' * indent}\033[0m\033[1;91merror: \033[0m{e}')