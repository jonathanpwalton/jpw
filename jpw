#!/usr/bin/env bash

declare -ri TRUE=0
declare -ri FALSE=1

declare -r JPW="/var/lib/jpw"
declare -r PKG="$JPW/pkg"
declare -r DBA="$JPW/available"
declare -r DBI="$JPW/installed"
declare -r STI="$JPW/.install"
declare -r STR="$JPW/.remove"
declare -r WRK="jpw-worker-$(cat /proc/sys/kernel/random/uuid)"

function rooted {
  return $(( EUID == 0 ? TRUE : FALSE ))
}

function warn {
  echo "warning: $1"
}

function fail {
  echo "error: $1"
  exit 1
}

enlist_worker(){
	useradd -M "$WRK"
}

direct_worker(){ # cmd
	su "$WRK" -c "$1"	
}

retire_worker(){
	userdel -f "$WRK"
}

function download {
  if [[ -n $2 ]]; 
    then wget "$1" -q --show-progress --progress=bar:force:noscroll --no-cache -O "$2"
    else wget "$1" -q --show-progress --progress=bar:force:noscroll --no-cache
  fi

  case $? in
    0 ) return 0 ;;
    4 ) fail "network failure" ;;
    * ) fail "failed to retrieve $1" ;;
  esac
}

function cmd::update {
  if ! rooted; then
    fail "cannot update without root privilege"
  fi

  download https://raw.githubusercontent.com/jonathanpwalton/jpw/main/available $DBA
}

function cmd::install {
  if ! rooted; then
    fail "cannot install without root privilege"
  elif [[ -z $1 ]]; then
    fail "install requires one or more packages as operands, see '$0 help' for more information"
  elif ! [[ -e $DBA ]]; then
    fail "the available package database has not been initialized, run '$0 update' first"
  fi

  while (($#)); do
    local pkg=$1; shift
    if [[ $1 = -v ]]; then shift; local ver=$1; shift; else local ver="latest"; fi
    if [[ $1 = -c ]]; then shift; local cfg=$1; shift; else local cfg=""; fi

    if ! /usr/bin/env bash $DBA "$pkg"; then
      warn "package '$pkg' not found, skipping"
      continue
    fi

    if [[ $ver = latest ]]; then
      ver=$(/usr/bin/env bash $DBA "$pkg" "latest")
      local -i upg=TRUE
    else
      local -i upg=FALSE
    fi

    if ! /usr/bin/env bash $DBA "$pkg" "$ver"; then
      warn "package '$pkg' version '$ver' not found, skipping"
      continue
    fi

    if /usr/bin/env bash $DBI "$pkg"; then
      local -l answer
      read -p "warning: package '$pkg' is already installed, remove and replace? [Y] " -r answer

      if [[ -z $answer ]] || [[ $answer = "y" || $answer = "yes" ]]; then
        echo "removing and replacing package '$pkg'"
        echo "$pkg" >> $STR
      else
        echo "skipping installation of package '$pkg'"
        continue
      fi
    fi
    
    {
      echo "$pkg"
      echo "$ver"
      echo "$cfg"
      echo "$upg"
    } >> $STI
  done

  staged::remove
  staged::install
}

function cmd::list {
  if [[ $1 = "available" ]]; then
    if [[ -e $DBA ]]; then
      grep -E ": 'pkg'" $DBA | grep -E -o "\S+)" | sed -E "s/\)//g"
    else
      fail "the available package database has not been initialized, run '$0 update' first"
    fi
  else
    fail "list requires one of the following operands: {available | installed}"
  fi
}

function cmd::help {
  echo "jpw 2025.03.27, a coreutils-based package manager for GNU/Linux"
  echo
  echo "usage: $program <command>"
  echo
  echo "commands:"
  echo "  help          display this help text and quit"
  exit 0
}

function staged::remove {
  if ! [[ -e $STR ]]; then
    return 0
  fi

  local -a pkgs
  mapfile -t pkgs < $STR; rm -f $STR

  local pkg
  for pkg in "${pkgs[@]}"; do
    fail "unimplemented remove pkg '$pkg'"
  done
}

function staged::install {
  if ! [[ -e $STI ]]; then
    return 0
  fi

  local -a lines
  mapfile -t lines < $STI; rm -f $STI

  local i
  for ((i=0; i < ${#lines[@]}; i+=4)) do
    local pkg=${lines[(i + 0)]}
    local ver=${lines[(i + 1)]}
    local cfg=${lines[(i + 2)]}
    local -i upg=${lines[(i + 3)]}

    local src=$(/usr/bin/env bash $DBA "$pkg" "$ver" src)
    local dst=$(/usr/bin/env bash $DBA "$pkg" "$ver" dst)
    local bld=$(/usr/bin/env bash $DBA "$pkg" "$ver" bld)

    if [[ -z "$src" ]] || [ -z "$dst" ] || [ -z "$bld" ]; then
      warn "cannot install package '$pkg' due to invalid formatting in the available package database"
      continue
    fi

    mkdir -p "$PKG/$pkg"
    cd "$PKG/$pkg" || continue
    download "$src"
    tar xf "$(basename "$src")"
    rm -f "$(basename "$src")"
    cd "$PKG/$pkg/$dst" || continue
    
    case "$bld" in
      gnu )
        enlist_worker
        chown -R "$WRK" "$PKG/$pkg/$dst"
        direct_worker "./configure $cfg"
        direct_worker "make"
        make install
        direct_worker "make clean"
        chown -R "$(id -nu $EUID)" "$PKG/$pkg/$dst"
        retire_worker

        echo "cd $PKG/$pkg/$dst" > "$PKG/$pkg/uninstall"
        echo "make uninstall" >> "$PKG/$pkg/uninstall"
      ;;
      * )
        fail "building '$bld' is not implemented"
    esac

    local rule=$'s/^#REPLACEME/'
    rule+="\"$pkg\") : 'pkg'; case \$2 in "") exit 0 ;; ver) echo \$'$ver'; exit 0 ;; cfg) echo \$'$cfg'; exit 0 ;; upg) exit $upg ;; esac; exit 0;;\\n"
    rule+="#REPLACEME"
    rule+=$'/g'
    sed "$rule" -i $DBI
  done
}

function main {
  local program=$0
  local command=$1; shift

  if rooted; then
    mkdir -p $PKG

    if ! [[ -e $DBI ]]; then
      {
        echo '#!/usr/bin/env bash'
        echo
        echo 'case "$1" in'
        echo '#REPLACEME'
        echo '  *)'
        echo '    exit 1'
        echo '  ;;'
        echo 'esac'
      } > $DBI
    fi

    if [[ -e $STI ]]; then
      rm -f $STI
    fi

    if [[ -e $STR ]]; then
      rm -f $STR
    fi
  fi

  case "$command" in
    update ) cmd::update "$@" ;;
    list ) cmd::list "$@" ;;
    install ) cmd::install "$@" ;;
    help ) cmd::help "$@" ;;
    * ) fail "missing or invalid command, see '$program help' for more information" ;;
  esac
}

main "$@"
